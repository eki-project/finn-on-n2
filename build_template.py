import sys
import finn.builder.build_dataflow as build
import finn.builder.build_dataflow_config as build_cfg
import os
import shutil
from argparse import ArgumentParser
from typing import Final, Callable

DEFAULT_OUT_DIR:    Final[str]                  = "out_dir"
DEFAULT_STEPS:      Final[list[str | Callable]] = [
    "step_qonnx_to_finn",
    "step_tidy_up",
    "step_streamline",
    "step_convert_to_hls",
    "step_create_dataflow_partition",
    "step_target_fps_parallelization",
    "step_apply_folding_config",
    "step_generate_estimate_reports",
    "step_hls_codegen",
    "step_hls_ipgen",
    "step_set_fifo_depths",
    "step_create_stitched_ip",
    "step_measure_rtlsim_performance",
    "step_out_of_context_synthesis",
    "step_synthesize_bitfile",
    # "step_make_cpp_driver",
    "step_make_pynq_driver",
    "step_deployment_package",
]
DEFAULT_PLATFORM:               Final[str] = "xilinx_u280_gen3x16_xdma_1_202211_1"
DEFAULT_BOARD:                  Final[str] = "U280"
DEFAULT_MVAU_MAX_WIDTH:         Final[int] = 80
DEFAULT_TARGET_FPS:             Final[int] = 100_000
DEFAULT_SYNTH_CLK_NS:           Final[float] = 10.0
DEFAULT_AUTO_FIFO_DEPTH:        Final[bool] = True
DEFAULT_SHELL_FLOW:             Final[build_cfg.ShellFlowType] = build_cfg.ShellFlowType.VITIS_ALVEO
DEFAULT_OUTPUT_GENS:            Final[list[build_cfg.DataflowOutputType]] = [
    build_cfg.DataflowOutputType.STITCHED_IP,
    build_cfg.DataflowOutputType.RTLSIM_PERFORMANCE,
    build_cfg.DataflowOutputType.OOC_SYNTH,
    build_cfg.DataflowOutputType.BITFILE,
    build_cfg.DataflowOutputType.PYNQ_DRIVER,
    build_cfg.DataflowOutputType.DEPLOYMENT_PACKAGE,
] 


# Check to see whether we resume execution
# TODO: Re-enable this, as soon as env variables are not needed to do this anymore!
#parser = ArgumentParser()
#parser.add_argument("--resume", "-r", default="", help="This flag can be used to resume the flow from an advanced step to save time. Pass the name of a step in your flow and the flow will resume from there onwards. To have this work it is required that all temporary files generated by FINN are still in place and the step was reached before (so that the corresponding onnx file could be generated)")
#args = parser.parse_args()
#resume = args.resume
resume = os.environ["BUILD_FLOW_RESUME_STEP"]


# Set model name and steps
if resume == "": 
    #! This string will be templated by doit
    model_file = "<ONNX_INPUT_NAME>"
    actual_steps = DEFAULT_STEPS
else:
    model_file = os.path.join(DEFAULT_OUT_DIR, "intermediate_models", resume + ".onnx")
    if not os.path.isfile(model_file):
        print(f"ERROR: Cannot resume from step {resume} because corresponding model file could not be found at {model_file}")
        sys.exit()
    found = False
    actual_steps = []
    for step in DEFAULT_STEPS:
        step_name = step if type(step) == str else step.__name__
        if step_name == resume:
            found = True
        if found:
            actual_steps.append(step)


cfg_stitched_ip = build.DataflowBuildConfig(
    output_dir              = DEFAULT_OUT_DIR,
    steps                   = actual_steps,
    vitis_platform          = DEFAULT_PLATFORM,
    board                   = DEFAULT_BOARD,
    mvau_wwidth_max         = DEFAULT_MVAU_MAX_WIDTH,
    target_fps              = DEFAULT_TARGET_FPS,
    synth_clk_period_ns     = DEFAULT_SYNTH_CLK_NS,
    force_rtl_conv_inp_gen  = True,
    auto_fifo_depths        = DEFAULT_AUTO_FIFO_DEPTH,
    rtlsim_use_vivado_comps = False,
    split_large_fifos       = True,
    shell_flow_type         = DEFAULT_SHELL_FLOW,
    generate_outputs        = DEFAULT_OUTPUT_GENS
    )

build.build_dataflow_cfg(model_file, cfg_stitched_ip)

